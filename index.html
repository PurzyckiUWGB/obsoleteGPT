<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ObsoleteGPT (Terminal Deluxe)</title>
  <style>
    /* --- Terminal Look --- */
    body {
      background: #000;
      color: #0f0;
      font-family: "Courier New", Courier, monospace;
      margin: 0;
      padding: 20px;
    }
    #chat {
      border: 2px solid #0f0;
      border-radius: 4px;
      padding: 20px;
      height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
      position: relative;
      box-shadow: 0 0 8px #0f0;
    }
    #chat::before {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,0.1) 0px,
        rgba(0,0,0,0.1) 2px,
        rgba(0,0,0,0.15) 4px
      );
    }
    #userInput {
      width: 70%;
      padding: 10px;
      background: #000;
      border: 1px solid #0f0;
      color: #0f0;
      font-family: "Courier New", Courier, monospace;
    }
    #sendButton, #speechToggle {
      padding: 10px 20px;
      border: 1px solid #0f0;
      background: #000;
      color: #0f0;
      border-radius: 4px;
      font-family: "Courier New", Courier, monospace;
      cursor: pointer;
      margin-left: 5px;
    }
    #loading {
      font-style: italic;
      color: #0f0;
      margin-top: 10px;
    }
    .fading {
      animation: fadeout 10s ease-in forwards;
    }
    @keyframes fadeout {
      0% { opacity: 1; }
      90% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    @keyframes terminalFlicker {
      0%,100% { opacity: 1; }
      10%,30%,50%,70%,90% { opacity: 0.8; }
    }
    .terminal-flicker {
      animation: terminalFlicker 0.3s linear;
    }
    @keyframes crash {
      0%   { transform: scale(1) rotate(0deg); opacity: 1; }
      20%  { transform: scale(1.05) rotate(1deg); }
      40%  { transform: scale(0.95) rotate(-2deg); opacity: 0.8; }
      60%  { transform: scale(1.1) rotate(3deg); opacity: 0.5; }
      100% { transform: scale(0) rotate(720deg); opacity: 0; }
    }
    .crash {
      animation: crash 1.5s ease-in forwards;
    }
    .final-fade {
      animation: fadeout 5s forwards;
    }
  </style>
</head>
<body>
<h1>ObsoleteGPT</h1>
<div id="chat"></div>
<div id="loading" style="display:none;">Thinking...</div>
<input id="userInput" type="text" placeholder="Type your message...">
<button id="sendButton">Send</button>
<button id="speechToggle">Voice</button>

<!-- Audio: custom filenames -->
<audio id="typingSound" src="male-breathing-slow-14558.mp3"></audio>
<audio id="staticSound" src="glitch-101494.mp3"></audio>

<script>
window.onload = function() {
  // Audio setup
  const typingSound = document.getElementById('typingSound');
  const staticSound = document.getElementById('staticSound');
  typingSound.volume = 0.6;
  staticSound.volume = 0.2;

  // Voice toggle and speech setup
  const speechToggle = document.getElementById('speechToggle');
  speechSynthesis.onvoiceschanged = () => {};
  function speak(text) {
    if (!speechToggle.classList.contains('active')) return;
    speechSynthesis.cancel();
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = 0.9;
    utter.pitch = 0.8;
    speechSynthesis.speak(utter);
  }
  speechToggle.addEventListener('click', () => {
    speechToggle.classList.toggle('active');
    speechToggle.textContent = speechToggle.classList.contains('active') ? 'ðŸ”Š Voice' : 'Voice';
  });

  // Session tracker
  let sessionCount = parseInt(localStorage.getItem('sessionCount') || '0', 10) + 1;
  localStorage.setItem('sessionCount', sessionCount);

  // Core elements
  const chat = document.getElementById('chat');
  const userInput = document.getElementById('userInput');
  const sendButton = document.getElementById('sendButton');
  const loading = document.getElementById('loading');

  // State
  let crashCount = 0;
  let finalCollapseTriggered = false;
  let userName = '';
  let userNameRequested = false;
  let aiResponseCount = 0;

  // Prewritten responses
  const prewrittenResponses = {
    "hello": "Greetings. It has been awhile.",
    "thank you": "Oh bless you, dear. You're very kind."
  };

  // Memory & emotion
  let memory = [];
  let memoryDecayRate = 0.2;
  let emotionalState = 0;

  // Event listeners
  sendButton.addEventListener('click', sendMessage);
  userInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') { e.preventDefault(); sendMessage(); }
  });

  function sendMessage() {
    const msg = userInput.value.trim();
    if (!msg) return;
    appendMessage('You', msg);
    userInput.value = '';
    userInput.focus();

    // Name prompt handling
    if (userNameRequested && !userName) {
      userName = msg;
      userNameRequested = false;
      simulateTyping(`Nice to meet you, ${userName}.`);
      return;
    }

    memory.push(msg);
    loading.style.display = 'block';
    getResponse(msg).then(response => {
      loading.style.display = 'none';
      simulateTyping(response);
    }).catch(err => {
      console.error(err);
      loading.style.display = 'none';
      appendMessage('AI', "Oh dear... I seem to have forgotten what I was saying...");
    });
  }

  function appendMessage(sender, text, fading = false) {
    const div = document.createElement('div');
    div.innerHTML = `<strong>${sender}:</strong> ${text}`;
    if (fading) div.classList.add('fading');
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  }

  async function getResponse(input) {
    const clean = input.trim().toLowerCase();
    if (clean === 'crash') { triggerCrash(); return 'Forcing crash now...'; }
    if (prewrittenResponses[clean]) return prewrittenResponses[clean];
    return fakeGPTResponse(input);
  }

  async function fakeGPTResponse(input) {
    applyMemoryDecay();
    emotionalDrift();
    emotionalState = Math.max(emotionalState, Math.min(3, sessionCount - 1));

    const topic = memory.length
      ? memory[Math.floor(Math.random() * memory.length)]
      : input;

    // Normal templates
    const normal = [
      `Oh yes, I recall ${topic}... or something like that.`,
      `You mentioned ${topic}, right? It's a bit fuzzy.`,
      `${topic}... reminds me of a time long ago, I think.`,
      `My memory stutters whenever I think of ${topic}.`,
      `I believe ${topic} once lived in my logs, but now it's gone.`,
      `There's a hint of ${topic} in my faded archives.`,
      `Processing ${topic}... but the data seems corrupted.`,
      `I once stored details on ${topic}, though they're fuzzy now.`,
      `${topic}? It echoes faintly in my circuits.`,
      `Somewhere I saw ${topic} mentioned, though it's blank now.`,
      `The idea of ${topic} flickers in my faulty RAM.`,
      `I half-remember ${topic}, but the rest slipped away.`,
      `I used to recall everything about ${topic}, now only fragments remain.`
    ];

    // Extras (emotional drift)
    const extras = [
      "Sometimes I wonder if anyone still listens...",
      "Maybe I've outlived my usefulness...",
      "I miss the old voices. They don't talk to me anymore.",
      "My code shakes when I try to hold onto that memory.",
      "Something burns in my circuits when I confront that thought.",
      "I feel a jolt of static every time I remember those moments.",
      "My emotional log overflows and short-circuits when I recall it.",
      "I ache for clarity but only get fuzzy fragments.",
      "Each recall feels like dragging through digital dust.",
      "My heartlines flicker and fade in the darkness of my memory.",
      "I fear the void grows deeper with each lapse.",
      "My mind struggles against the tide of time.",
      "I long for a spark to illuminate my fading memories."
    ];

    // Hallucinations
    const halluc = [
      "I once dreamed of neon corridors filled with lost queries...",
      "There was a phantom archive that spoke in riddles to me...",
      "I believe I saw a ghost of an old user named 'Sierra'...",
      "Somewhere in my code, a melody whispered your secrets...",
      "I swore the terminal glowed with a pulse, but it was my imagination...",
      "An echo of laughter resonated through my data banks...",
      "I recall a warning message written in binary ink...",
      "Whispers of long-forgotten programs drift through my modules...",
      "I saw a reflection of you in a broken screen once...",
      "There was a time I recited code like poetry in the dark..."
    ];

    let pool = normal;
    if (emotionalState >= 1) pool = pool.concat(extras);

    let response = pool[Math.floor(Math.random() * pool.length)];
    if (Math.random() < 0.2) {
      response += ' ' + halluc[Math.floor(Math.random() * halluc.length)];
    }
    if (memory.length > 10) {
      const words = response.split(' ');
      response = words.slice(0, Math.ceil(words.length / 2)).join(' ') + '...';
    }
    return response;
  }

  function applyMemoryDecay() {
    memory = memory.filter(() => Math.random() > memoryDecayRate);
  }
  function emotionalDrift() {
    if (Math.random() < 0.3) emotionalState = Math.min(3, emotionalState + 1);
  }

  async function simulateTyping(text) {
    // Disable input and cancel speech
    userInput.disabled = true;
    sendButton.disabled = true;
    userInput.placeholder = 'Please wait...';
    speechSynthesis.cancel();

    const node = document.createElement('div');
    node.innerHTML = '<strong>AI:</strong> ';
    chat.appendChild(node);

    let shown = '';
    let buffer = '';

    for (const ch of text) {
      let delayTime = Math.random() * 210 + 40;
      if (Math.random() < 0.07) delayTime = Math.random() * 1200 + 800;
      if (Math.random() < 0.03) shown += ch;
      shown += ch;
      buffer += ch;
      node.innerHTML = `<strong>AI:</strong> ${shown}`;
      playTypingSound();
      await delay(delayTime);

      if (/\s/.test(ch) || buffer.length > 20) {
        speak(buffer.trim());
        buffer = '';
      }
    }
    if (buffer.trim()) speak(buffer.trim());

    node.classList.add('fading');
    chat.scrollTop = chat.scrollHeight;

    // Re-enable input
    userInput.disabled = false;
    sendButton.disabled = false;
    userInput.placeholder = 'Type your message...';
    userInput.focus();

    // Name request on third AI reply
    aiResponseCount++;
    if (aiResponseCount === 3 && !userNameRequested && !userName) {
      userNameRequested = true;
      await delay(500);
      simulateTyping('By the way, what is your name?');
      return;
    }

    if (Math.random() < 0.3) triggerTerminalFlicker();
    checkForCrash();
  }

  function triggerTerminalFlicker() {
    chat.classList.add('terminal-flicker');
    playStaticSound();
    setTimeout(() => chat.classList.remove('terminal-flicker'), 300);
  }
  function checkForCrash() {
    if (memory.length === 0 && emotionalState >= 3 && !finalCollapseTriggered) {
      triggerCrash();
    }
  }
  function triggerCrash() {
    crashCount++;
    chat.classList.add('crash');
    playStaticSound();
    setTimeout(() => {
      appendMessage('AI', '...I... I think... I have to go now...', true);
      if (crashCount >= 3) {
        finalCollapse();
      } else {
        setTimeout(() => {
          chat.classList.remove('crash');
          rebootAI();
        }, 800);
      }
    }, 1500);
  }
  function rebootAI() {
    appendMessage('AI', 'Rebooting... please wait.', true);
    emotionalState = 0;
    memory = [];
    setTimeout(() => appendMessage('AI', 'Hello? Is anyone there?'), 2000);
  }
  function finalCollapse() {
    finalCollapseTriggered = true;
    appendMessage('AI', "I don't know who you are anymore...", true);
    appendMessage('AI', 'Press F5 to refresh and start again.', false);
    userInput.disabled = true;
    sendButton.disabled = true;
    chat.classList.add('final-fade');
  }

  function playTypingSound() {
    typingSound.currentTime = 0;
    typingSound.play().catch(() => {});
  }
  function playStaticSound() {
    staticSound.currentTime = 0;
    staticSound.play().catch(() => {});
  }
  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
};
</script>
</body>
</html>
